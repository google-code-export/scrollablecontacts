#summary launcher- and widget-developer guide to API version 2
#labels Deprecated,Phase-Implementation

= Introduction =

Hi there everyone,

I've worked the last week on a new scrollable widget API which is much more flexible then the previous one. Let me say that the old API is fully compatible! This document might help you all to use these changes.
Here some things that are new:

=== Metadata requirements ===

As a widget dev you can now add some nodes to your AndroidManifest.xml to tell the launcher that you need a specific API version or that your widget needs to be scrollable or animated. Read more about it in the two dev sections ;)

=== RemoteViews ===

The ListViews / GridViews and its content can now be described by two variants of RemoteViews which brings much more flexibility to the widget development. More about it in the widget dev section!

= For launcher devs =

As you see in the Launcher.java from the L+ code I have added some "meta-data-checks" in the addAppWidget method.

There currently is only the check for the API version. 
But in the new LauncherMetadata.java are some other "metadata names" defined.
You should check them too if they are relevant for your launcher!

For example:
If you have a setting to enable/disable scrollable widget support then you might check the
LauncherMetadata.Requirements.Scrollable meta-data too. If that meta-data is set to true the widget needs scrollable support. You might ask the user if he / she wants to enable that setting if it is disabled or also drop the widget.

Please do us widget devs a favor and tell the user why you don't add a widget. This would reduce the amount of unnecessary support requests we have to answer ;)

So please read the changes I've done in the Launcher.java try to understand them and do what you have to do ;)

= For widget devs =

=== Metadata requirements ===

you can now tell the launcher what you need for your widget and the launcher will decide if it can provide that requirements or not... That will reduce the number of "dumb support requests".

See this sample of AndroidManifest.xml :

{{{
  <receiver android:name="SampleWidget" android:label="@string/SampleWidget">
    <intent-filter>
      <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
    </intent-filter>
    <meta-data android:name="android.appwidget.provider"
               android:resource="@xml/contact_widget_provider4x4" />

    <!-- Here is the new code: -->

    <!-- require at least api version 2 -->
    <meta-data android:name="LauncherMetadata.Requirements.APIVersion" 
               android:value="2" />

    <!-- require scrollable support -->
    <meta-data android:name="LauncherMetadata.Requirements.Scrollable"
               android:value="true" />

    <!-- require animation support -->
    <meta-data android:name="LauncherMetadata.Requirements.Animation"
               android:value="true" />
  </receiver>

}}}

=== RemoteViews ===

I hope you will love this as much as I do ;)
I have added a possibility to use a RemoteViews like class to tell the launcher how the ListViews and the Items shall look like.

Lets start with the ListView/GridView. Instead of passing the layout resource id within the intent (EXTRA_LISTVIEW_LAYOUT_ID) you can now pass an instance of "SimpleRemoteViews"
Let me show you a sample to make this more clear. Imagine you have a GridView and want to set the number of columns based on your settings. Previously you had to have a layout for each variation now you can to it this way:
{{{
    // Create a new instance of SimpleRemoteViews and pass the "base layout"
    SimpleRemoteViews gridView = new SimpleRemoteViews(R.layout.gridview);
    // now tell the launcher to set the columns to colCount
    gridView.setInt(R.id.my_gridview, "setNumColumns", colCount);
    // pass it to the launcher within the ACTION_SCROLL_WIDGET_START intent
    result.putExtra(LauncherIntent.Extra.Scroll.EXTRA_LISTVIEW_REMOTEVIEWS, gridViews);
}}}

For the ListViewItems you could use a similar way (instead of passing the EXTRA_ITEM_LAYOUT_ID):

{{{
  // Create a BoundRemoteViews instance for the entry_small_black layout
  BoundRemoteViews itemViews = new BoundRemoteViews(R.layout.entry_small_black);

  // Now "bind" the text of the DataProviders name column to the text of 
  // the R.id.displayname which is a TextView
  itemViews.setBoundCharSequence(R.id.displayname, "setText", 
                                 DataProvider.DataProviderColumns.name.ordinal(),
                                 0); // <-- 0 = default resource id 'none'

  // "bind" the bitmap in the photo column of the DataProvider to the ImageView
  // and use R.drawable.no_image as fallback value.
  itemViews.setBoundBitmap(R.id.photo, "setImageBitmap",
                           DataProvider.DataProviderColumns.photo.ordinal(),
                           R.drawable.no_image);
}}}

even the click events for the items are more flexible. Cause you can setup a sample intent for the clicking: 

{{{
  // Create the sample intent:
  Intent intent = new Intent(LauncherIntent.Action.ACTION_VIEW_CLICK);

  // put the appWidgetId to the sample intent
  // you could also put other extras to that!
  intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
		
  // Now set the sample intent to to the onClick of R.id.photo
  itemViews.SetBoundOnClickIntent(R.id.photo, intent, 
           // and put the DataProviders contacturi-column value to
           // the extra name EXTRA_ITEM_POS
                                  LauncherIntent.Extra.Scroll.EXTRA_ITEM_POS,
                                  DataProvider.DataProviderColumns.contacturi.ordinal());
}}}

I know this sometimes is more coding but this brings so much more flexibility ;)

Oh and you dont have to pass the following extras if you use this new method:
  * EXTRA_LISTVIEW_LAYOUT_ID
  * EXTRA_ITEM_LAYOUT_ID
  * EXTRA_ITEM_CHILDREN_CLICKABLE
  * EXTRA_VIEW_IDS
  * EXTRA_VIEW_TYPES
  * EXTRA_VIEW_CLICKABLE
  * EXTRA_CURSOR_INDICES
  * EXTRA_DEFAULT_RESOURCES


You now also get an additional extra within the ACTION_READY intent:
LauncherIntent.Extra.EXTRA_API_VERSION which contains the maximum API version the launcher  can provide. If the extra is not specified the Version is 1 (the one before this patch)

If there are any questions left just ask me ;)

Regards
Florian